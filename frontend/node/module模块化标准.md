### 前端模块化四大规范

在js发展的早期,一直都没有自己的模块化方案,没有办法将一个大的程序、文件拆分成若干个小文件,然后再用简单的方法拼接.其他众多开发语言都有类似功能,如Ruby有require机制,Python有import机制,css也有@import.但是js没有类似的支持,在一些大型、复杂的项目中形成了很大的障碍.

在ES6之前,社区制定、推出了一些模块化方案,也得到了很大范围的推广和应用,如应用于服务端的CommonJS(CJS),以及应用于浏览器端的AMD.ES6在语言标准的层面上,实现了模块功能,而且实现的相对简单,完全可以取代社区推出的且已经应用很广泛的CommonJS和AMD规范,称为浏览器端和服务端通用的模块化解决方案.

在前端领域的模块化规范常用的有4个,分别为:CommonJs、AMD、CMD、ES6模块,除此之外用的相对较多的还有UMD和SystemJS.

#### CommonJS

CommonJS和AMD都是社区推出的模块化方案,并不是语言上的标准.

#### AMD

#### CMD

#### ES6模块

ES6模块的设计思想是尽量的静态化,在代码编译阶段就能确定模块之间的依赖关系,以及模块的输入、输出变量.这点和CommonJS以及AMD的模块化标准,有很大的区别,CommonJS和AMD都只能在运行时才能确定模块之间的依赖关系,如CommonJS模块就是对象

##### 概述

ES的模块化分为导出(export)和导入(import)两个模块

##### 特点

- ES6的模块化自动开启严格模式,无论模块顶部是否加入了"use strict"声明;

- 模块中可以导出和导入各种类型的变量,如函数、对象、字符串、数字、布尔值、类等;

- 每个模块都有自己的上下文,每个模块内部声明的变量都是局部变量,不会污染全局作用域;

- 每个模块只加载一次(单例模式),如果再次加载同一个目录下的同一个文件,那么会直接从内存中读取;

#### 疑惑/待确认

ES6每个文件都是一个模块

**ES6模块与CommonJS模块有什么不同?**

当CommonJS模块化中使用require(path)导入一个模块时,CommonJS会将path模块运行一遍,并返回一个对象,然后将这个对象缓存起来,这个对象包含path模块的所有API.以后无论多少次加载这个path模块但是取的值都是缓存起来的值,也就是第一次运行时的结果,除非手动清除.

ES6使用import导入path模块时,只会加载path模块中的3个方法,其他的方法不会加载,这就是编译时加载.ES6可以在编译时就完成模块的加载,当ES6遇到import时,不会像CommonJS去完整的执行一遍这个被引入的模块,然后把这个模块去缓存下来,而是生成一个动态的只读引用,当真正需要的时候再去模块里去取相应的值.

ES6中每个文件是一个模块,或者说一个模块就是一个独立的文件,但是该文件不可被直接引用,因为ex6中通过export导出的并不是模块本身,而是模块中的变量.该变量包括函数、方法、类、定义的变量、常量等.

### UMD和SystemJS

