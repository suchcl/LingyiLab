### 前端模块化四大规范

前端模块化规范,也可以简单理解为前端模块化标准.有的时候这么理解会更简单,规范就是标准,标准了也就是规范了.

在js发展的早期,是没有模块的概念的,如果想要实现类似其他开发语言的模块的能力,需要通过引入第三方库的方式来实现,但是随着前端技术的发展,前后端分离式开发,前端的业务变的越来越复杂,模块化的重要性也是日益体现.不过也还是通过第三方库的方式来实现,直到ES6标准的推出,JS从原生语法上支持了模块化.自此,模块化在前端领域的应用范围快速扩大.

在前端领域的模块化规范常用的有4个,分别为:CommonJs、AMD、CMD、ES6模块,除此之外用的相对较多的还有UMD和SystemJS.

#### CommonJS

CommonJS和AMD都是社区推出的模块化方案,并不是语言上的标准.

#### AMD

#### CMD

#### ES6模块

ES6模块的设计思想是尽量的静态化,在代码编译阶段就能确定模块之间的依赖关系,以及模块的输入、输出变量.这点和CommonJS以及AMD的模块化标准,有很大的区别,CommonJS和AMD都只能在运行时才能确定模块之间的依赖关系,如CommonJS模块就是对象

##### 概述

ES从ES6开始从语言标准层面引入了模块化概念,其设计思想是在编译阶段就能确定模块之间的依赖关系,以及确定输入和输出变量

ES的模块化分为导出(export)和导入(import)两个模块

##### 特点

- ES6的模块化自动开启严格模式,无论模块顶部是否加入了"use strict"声明;

- 模块中可以导出和导入各种类型的变量,如函数、对象、字符串、数字、布尔值、类等;

- 每个模块都有自己的上下文,每个模块内部声明的变量都是局部变量,不会污染全局作用域;

- 每个模块只加载一次(单例模式),如果再次加载同一个目录下的同一个文件,那么会直接从内存中读取;

#### 疑惑/待确认

ES6每个文件都是一个模块

**ES6模块与CommonJS模块有什么不同?**

当CommonJS模块化中使用require(path)导入一个模块时,CommonJS会将path模块运行一遍,并返回一个对象,然后将这个对象缓存起来,这个对象包含path模块的所有API.以后无论多少次加载这个path模块但是取的值都是缓存起来的值,也就是第一次运行时的结果,除非手动清除.

ES6使用import导入path模块时,只会加载path模块中的3个方法,其他的方法不会加载,这就是编译时加载.ES6可以在编译时就完成模块的加载,当ES6遇到import时,不会像CommonJS去完整的执行一遍这个被引入的模块,然后把这个模块去缓存下来,而是生成一个动态的只读引用,当真正需要的时候再去模块里去取相应的值.

### UMD和SystemJS

