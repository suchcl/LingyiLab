<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [1. 进程和线程的概念](#1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5)
- [2. 浏览器中的进程](#2-%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B)
- [3. 浏览器中都有哪些进程？](#3-%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E8%BF%9B%E7%A8%8B)
- [4. 浏览器线程](#4-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BA%BF%E7%A8%8B)
- [5. 总结](#5-%E6%80%BB%E7%BB%93)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

### 1. 进程和线程的概念

1. 进程：进程是CPU进行资源分配的最小单位，是能够拥有资源和独立运行的最小单位，进程之间不会共享资源；

2. 线程: 线程是CPU调度的最小单位，线程是建立在进程基础之上的一次程序运行单位，一个进程可以有多个线程，多个线程共享进程的资源；

3. 不同进程之间相互隔离，但是也可以相互通信，只是代价有点大。

看到过一个形象生动的比喻，就是进程和线程的关系，就好像是工厂和工厂里的工人一样，不同的工厂有自己的资源、空间，工厂里面也会有很多工人，工人是没有自己独立的资源和空间的，打算工厂里面的工人是可以共享工厂的资源和空间。同样，不同的工厂都是独立的，但是工厂与工厂之间也会有合作之类的关系，在达到了一定的要求、条件下，也可以实现一线资源或者空间的共享，会发生业务的往来。

### 2. 浏览器中的进程

浏览器的一些基础的共识：

1. 浏览器是多进程的；

2. 因为系统给浏览器分配了资源如CPU、内存等，所以浏览器能够运行；

3. 浏览器每打开一个页签，都相当于新开了一个独立的进程，不同的页签之间的进程都是独立的，它们互不影响。即使其中的一个页签由于某种原因崩溃了，也不会影响到其他页签的正常使用。之前的IE浏览器是不行的。

> 线程是共享资源的，同一个进程中的不同线程如果由于某种原因阻塞了，那么就会影响到其他线程的执行。

### 3. 浏览器中都有哪些进程？

现代浏览器(以Chrome浏览器为例)主要有以下几个进程：

1. 浏览器主进程：每个浏览器都只有1个浏览器主进程，主要负责界面展示、用户交互、子进程管理，同时提供存储功能；

2. 渲染进程：一个浏览器有多个渲染进程，其核心任务是将HTML、CSS和javascript转换为用户可以与之交互的网页，排版引擎Blink和javascript的V8引擎都是在该进程中。默认情况下，Chrome会为每个Tab都创建一个渲染进程。同时为了安全考虑，渲染进程都是运行在沙箱模式下。

3. 插件进程：主要负责插件的运行。浏览器中可以安装多个插件，但是由于插件的开发者质量参差不齐，容易崩溃，为了浏览器的使用体验，需要将插件进程来进行隔离，保证插件出了问题后不影响到整个浏览器的使用。

4. 网络进程：主要负责页面的网络资源架载，以前是作为浏览器进程里的一个模块运行，后来独立了出来，成为了一个单独的进程；

5. GPU进程：用于3D效果绘制。Chrome早期是没有GPU进程的，最初使用GPU只是为了渲染3D CSS效果的，只是后来网页、Chrome的UI界面都采用GPU来绘制，使得GPU成为浏览器的普遍需求，最后Chrome在其多进程架构中引入来GPU进程。

> 主要有这几个进程，不是说只有这几个进程。

**浏览器多进程的优势**

1. 避免单个页签的崩溃影响到整个浏览器的使用；

2. 避免第三方插件的崩溃响应到整个浏览器的使用；

3. 多进程可以充分利用CPU的多核优势；

4. 方便使用沙箱模型隔离插件等进程，提高浏览器的稳定性和安全性；

虽然说了这么多的优势，但是其本质还是用空间换时间，牺牲内存。

### 4. 浏览器线程

浏览器线程主要存在于渲染进程里面，也就是我们常说的浏览器内核里面，浏览器内核中常用的几种引擎就是我们要使用的线程，主要有以下几种线程:

1. GUI渲染线程：

* 负责渲染浏览器界面，解析HTML、CSS、javascript，构建DOM树和RenderObject树，布局和绘制；

* 当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时，该线程会执行；

* 与js引擎互斥，当执行js引擎线程时，GUI会挂起，当任务队列空闲时，才会继续执行GUI

2. JS引擎线程：

* 也称为JS内核，负责处理js脚本程序；

* js引擎线程负责解析js脚本，运行代码；

* js引擎一直等待任务队列中任务的到来，然后加以处理，浏览器无论什么时候都只有一个js引擎线程在运行js程序；

* GUI渲染线程和JS引擎线程是互斥的，如果JS引擎线程执行时间过程，就会造成页面渲染不连贯，导致页面渲染卡顿、家在不连贯的现象；

3. 事件触发线程：

* 事件触发线程归属于浏览器而不是js引擎，用来控制事件循环(存在一个事件队列)；

* 当js引擎执行代码块如setTimeOut(也可能是来自浏览器内核的其他线程，如鼠标的点击事件、Ajax异步请求等)时会将对应的任务添加到事件线程中；

* 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待js引擎的处理;

* 由于js的单线程关系，所以这些待处理队列的事件都需要排队等待js引擎的处理(当js引擎空闲时才会被处理、执行)

4. 定时器触发线程：

* setInterval、setTimOut所在的线程；

* 浏览器定时计数器并不是由js引擎计数的(因为js引擎是单线程的，如果线程处于阻塞状态则会影响计数的准确性)

* 通过单独线程计时触发计时(计时完成后，添加到事件队列中，等待js引擎空闲后执行)

* W3C在HTML标准中规定要求setTimeOut中低于4ms的时间间隔规定为4ms

5. 异步HTTP请求线程(IO线程)：

* 在XMLHttpRequest连接后通过浏览器开启一个新的线程请求；

* 检测到有状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中(放入事件触发线程中)由js引擎执行；
### 5. 总结

1. 浏览器是多进程的；

2. js执行的主线程维js引擎，并且只有一个js线程在运行，所以是单线程执行；

3. GUI渲染线程和js引擎线程是互斥的，js的执行会阻塞页面的加载和渲染；

4. 定时器会在定时器触发器线程中进行计时；

5. 定时器触发器线程计时结束后要执行的事件和异步HTTP请求线程的回调事件都会进入到事件触发线程到任务队列中等待js引擎的执行；