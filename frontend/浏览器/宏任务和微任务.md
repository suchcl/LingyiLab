<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [1. 宏任务和微任务](#1-%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1)
  - [2. 宏任务](#2-%E5%AE%8F%E4%BB%BB%E5%8A%A1)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

### 1. 宏任务和微任务

微任务，可以在实时性和效率之间做一个有效的平衡。

微任务，已经被广泛的应用，目前基于微任务的技术有MutationObserver、Promise和很多以Promise为基础开发的很多周边应用。微任务的重要性逐渐提升。

还有一个与微任务对应的宏任务。

#### 2. 宏任务

页面中的大部分事件都是在主线程上执行的(现在的浏览器是多进程的，早期的浏览器是单进程的，Javascript是单线程的)，这些任务主要有：

1. 渲染事件：如DOM解析、样式计算、布局、绘制等

2. 用户交互事件：如鼠标点击、页面滚动、页面缩放等事件

3. javascript脚本执行事件

4. 网络请求完成、文件读写完成事件

为了协调这些任务有条不紊的在主线程上执行，页面进程引入了消息队列和事件循环机制。渲染进程内部会维护多个消息队列，比如延迟执行队列和普通的消息队列。然后主线程采用一个for循环，不断的从这些任务队列中取出任务并执行任务。我们把这些消息队列中的任务称为宏任务。

普通消息队列和延迟执行队列中的任务，都统称为宏任务。

消息队列中的任务是通过事件循环系统来执行的，大概的执行顺序如下：

1. 从多个消息队列中选出最老的任务，这个任务被称为是oldestTask；

2. 然后循环系统记录任务开始执行的时间，并把这个oldestTask设置为当前正在执行的任务；

3. 当任务执行完成之后，删除当前正在执行的任务，并从对应的消息队列中删除掉这个oldestTask；

4. 最后统计执行完成的时长等信息；

> 关于事件循环机制的介绍，可以参考：https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model，这里是最详细、最权威的介绍。

> 中文版的在这里：https://whatwg-cn.github.io/html/#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF

宏任务可以满足大部分的日常需求，但是有些对时间精度要求较高的续期，宏任务就难以满足。

我们知道，页面的渲染事件、各种IO的完成事件、执行js的脚本事件、用户交互事件等都可以随时被添加到消息队列中，但是添加事件到消息队列的动作是由系统操作的，js代码不能准确的掌握任务要添加的在消息丢列中的位置，所以也就很难精准的控制任务的执行时间。

> setTimeout函数出触发的回调函数都是宏任务。

宏任务的时间粒度比较大，执行的时间间隔不能被很好的精准控制，对于一些高实时性的需求不太能满足要求了，比如监听DOM变化的需求。这个时候就可以考虑使用微任务了。

> 微任务的产生，主要解决了宏任务无法兼顾的高实时性的问题，因为宏任务没有办法控制将任务加入到消息队列的时间，没有办法控制宏任务在消息队列中的位置，也就没有办法控制宏任务的执行时间。

### 3. 微任务

我们了解异步回调的概念，异步回调，主要有2种方式：

1. 把异步回调函数封装成一个宏任务，添加到消息队列的尾部，当循环系统执行到该任务的时候执行回调函数。

这种方式比较好理解，如setTimeout和XMLHttpRequest的回调函数就是通过这种方式来实现的。

2. 第二种方式的执行时机是在主函数执行结束之后、当前宏任务结束之前执行回调函数，这通常都是以微任务形式体现的。

**那么到底什么是微任务呢？**

当js在执行一段js的时候，V8会为其创建一个全局的执行上下文，在创建全局执行上下文的同时，V8引擎也会在内部创建一个微任务队列。这个微任务队列就是用来存放微任务的，在当前宏任务执行的过程中，有时候会产生多个微任务，这时候就需要使用这个微任务队列来保存这些微任务了。只是这个微任务队列是给V8引擎内部使用的，我们是没有办法通过js直接访问。

> 事件循环(Event Loop)是各浏览器厂商的，和js引擎(如V8)没有关系，只是浏览器给你提供一个机制，让引擎去执行某些代码。

根据上面的介绍，那就是说，每个宏任务都关联了一个微任务队列。既然这样，那我们就需要关注两个重要的时间点——微任务的产生时机和执行微任务队列的时机。

**微任务的产生**

在现代的浏览器里，产生微任务主要有两种方式：

1. 使用MutationObserver监控某个DOM节点，然后再通过Js来修改这个节点，或者为这个节点添加、删除子节点，当DOM发生变化时，就会产生DOM变化记录的微任务。

> MutationObserver本身不是微任务，而是当它监控的DOM节点发生了变化时产生的回调，是一个微任务。

2. 另外一种方式是使用Promise，当调用Promise.resolve()或者Promise.reject()的时候，也会产生微任务。

> 和MutationObserver一样，Promise本身并不是微任务，而是执行了当某条条件下触发了resolve或者reject的时候，这两个回调才是微任务。

当DOM节点变化产生的微任务或者使用Promise产生的微任务，都会被js引擎按照顺序保存到微任务队列中。

现在微任务队列中有了微任务了，那么接下来就看下微任务是如何被执行到。

一般情况下，当前宏任务中的js代码快要被执行完成时，即js引擎准备退出全局执行上下文并清空调用栈的时候，js引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行微任务队列中的微任务。**WHATWG把执行微任务的时间点称为检查点**。

如果在执行微任务的过程中又产生了新的微任务，也会把新产生的微任务也添加到微任务队列中，V8引擎移植循环执行微任务队列中的任务，直到队列为空才算执行结束。也就是说，在执行微任务的过程中产生的新的微任务并不会推迟到下个宏任务中去执行，而是在当前的宏任务中继续执行。

### 4. 宏任务和微任务的关系

1. 微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列；

> 微任务执行过程中产生的宏任务，也会被添加到消息队列或者延迟队列尾部，这需要到下一次的事件循环才有可能会被执行，而微任务在这一次事件循环之前就会被执行了。

2. 微任务的执行时长会影响到当前宏任务的执行时长。

比如在一个宏任务的执行过程中，产生了100个微任务，每个微任务的执行时长大概是10ms，那么执行这100个微任务就会消耗大概1000ms，那么也就是说微任务让当前的宏任务的执行时间延长了1000ms，所以在写代码的时候 ，一定要注意控制微任务的执行时长。

3. 在一个宏任务中，会分别创建一个用于回调的宏任务和微任务，无论在任何情况下，微任务都会早于宏任务执行。

> 当前宏任务中