<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [1. 宏任务和微任务](#1-%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1)
- [2. 宏任务](#2-%E5%AE%8F%E4%BB%BB%E5%8A%A1)
- [3. 微任务](#3-%E5%BE%AE%E4%BB%BB%E5%8A%A1)
- [4. 宏任务和微任务的关系](#4-%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%85%B3%E7%B3%BB)
- [5. 监听DOM变化方法的演变](#5-%E7%9B%91%E5%90%ACdom%E5%8F%98%E5%8C%96%E6%96%B9%E6%B3%95%E7%9A%84%E6%BC%94%E5%8F%98)
  - [5.1 相比较Mutation Event，MutationObserver做了哪些改进呢？](#51-%E7%9B%B8%E6%AF%94%E8%BE%83mutation-eventmutationobserver%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E6%94%B9%E8%BF%9B%E5%91%A2)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

### 1. 宏任务和微任务

微任务，可以在实时性和效率之间做一个有效的平衡。

微任务，已经被广泛的应用，目前基于微任务的技术有MutationObserver、Promise和很多以Promise为基础开发的很多周边应用。微任务的重要性逐渐提升。

还有一个与微任务对应的宏任务。

### 2. 宏任务

页面中的大部分事件都是在主线程上执行的(现在的浏览器是多进程的，早期的浏览器是单进程的，Javascript是单线程的)，这些任务主要有：

1. 渲染事件：如DOM解析、样式计算、布局、绘制等

2. 用户交互事件：如鼠标点击、页面滚动、页面缩放等事件

3. javascript脚本执行事件

4. 网络请求完成、文件读写完成事件

为了协调这些任务有条不紊的在主线程上执行，页面进程引入了消息队列和事件循环机制。渲染进程内部会维护多个消息队列，比如延迟执行队列和普通的消息队列。然后主线程采用一个for循环，不断的从这些任务队列中取出任务并执行任务。我们把这些消息队列中的任务称为宏任务。

普通消息队列和延迟执行队列中的任务，都统称为宏任务。

消息队列中的任务是通过事件循环系统来执行的，大概的执行顺序如下：

1. 从多个消息队列中选出最老的任务，这个任务被称为是oldestTask；

2. 然后循环系统记录任务开始执行的时间，并把这个oldestTask设置为当前正在执行的任务；

3. 当任务执行完成之后，删除当前正在执行的任务，并从对应的消息队列中删除掉这个oldestTask；

4. 最后统计执行完成的时长等信息；

> 关于事件循环机制的介绍，可以参考：https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model，这里是最详细、最权威的介绍。

> 中文版的在这里：https://whatwg-cn.github.io/html/#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF

宏任务可以满足大部分的日常需求，但是有些对时间精度要求较高的续期，宏任务就难以满足。

我们知道，页面的渲染事件、各种IO的完成事件、执行js的脚本事件、用户交互事件等都可以随时被添加到消息队列中，但是添加事件到消息队列的动作是由系统操作的，js代码不能准确的掌握任务要添加的在消息丢列中的位置，所以也就很难精准的控制任务的执行时间。

> setTimeout函数出触发的回调函数都是宏任务。

宏任务的时间粒度比较大，执行的时间间隔不能被很好的精准控制，对于一些高实时性的需求不太能满足要求了，比如监听DOM变化的需求。这个时候就可以考虑使用微任务了。

> 微任务的产生，主要解决了宏任务无法兼顾的高实时性的问题，因为宏任务没有办法控制将任务加入到消息队列的时间，没有办法控制宏任务在消息队列中的位置，也就没有办法控制宏任务的执行时间。

### 3. 微任务

我们了解异步回调的概念，异步回调，主要有2种方式：

1. 把异步回调函数封装成一个宏任务，添加到消息队列的尾部，当循环系统执行到该任务的时候执行回调函数。

这种方式比较好理解，如setTimeout和XMLHttpRequest的回调函数就是通过这种方式来实现的。

2. 第二种方式的执行时机是在主函数执行结束之后、当前宏任务结束之前执行回调函数，这通常都是以微任务形式体现的。

**那么到底什么是微任务呢？**

当js在执行一段js的时候，V8会为其创建一个全局的执行上下文，在创建全局执行上下文的同时，V8引擎也会在内部创建一个微任务队列。这个微任务队列就是用来存放微任务的，在当前宏任务执行的过程中，有时候会产生多个微任务，这时候就需要使用这个微任务队列来保存这些微任务了。只是这个微任务队列是给V8引擎内部使用的，我们是没有办法通过js直接访问。

> 事件循环(Event Loop)是各浏览器厂商的，和js引擎(如V8)没有关系，只是浏览器给你提供一个机制，让引擎去执行某些代码。

根据上面的介绍，那就是说，每个宏任务都关联了一个微任务队列。既然这样，那我们就需要关注两个重要的时间点——微任务的产生时机和执行微任务队列的时机。

**微任务的产生**

在现代的浏览器里，产生微任务主要有两种方式：

1. 使用MutationObserver监控某个DOM节点，然后再通过Js来修改这个节点，或者为这个节点添加、删除子节点，当DOM发生变化时，就会产生DOM变化记录的微任务。

> MutationObserver本身不是微任务，而是当它监控的DOM节点发生了变化时产生的回调，是一个微任务。

2. 另外一种方式是使用Promise，当调用Promise.resolve()或者Promise.reject()的时候，也会产生微任务。

> 和MutationObserver一样，Promise本身并不是微任务，而是执行了当某条条件下触发了resolve或者reject的时候，这两个回调才是微任务。

当DOM节点变化产生的微任务或者使用Promise产生的微任务，都会被js引擎按照顺序保存到微任务队列中。

现在微任务队列中有了微任务了，那么接下来就看下微任务是如何被执行到。

一般情况下，当前宏任务中的js代码快要被执行完成时，即js引擎准备退出全局执行上下文并清空调用栈的时候，js引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行微任务队列中的微任务。**WHATWG把执行微任务的时间点称为检查点**。

如果在执行微任务的过程中又产生了新的微任务，也会把新产生的微任务也添加到微任务队列中，V8引擎移植循环执行微任务队列中的任务，直到队列为空才算执行结束。也就是说，在执行微任务的过程中产生的新的微任务并不会推迟到下个宏任务中去执行，而是在当前的宏任务中继续执行。

### 4. 宏任务和微任务的关系

1. 微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列；

> 微任务执行过程中产生的宏任务，也会被添加到消息队列或者延迟队列尾部，这需要到下一次的事件循环才有可能会被执行，而微任务在这一次事件循环之前就会被执行了。

2. 微任务的执行时长会影响到当前宏任务的执行时长。

比如在一个宏任务的执行过程中，产生了100个微任务，每个微任务的执行时长大概是10ms，那么执行这100个微任务就会消耗大概1000ms，那么也就是说微任务让当前的宏任务的执行时间延长了1000ms，所以在写代码的时候 ，一定要注意控制微任务的执行时长。

3. 在一个宏任务中，会分别创建一个用于回调的宏任务和微任务，无论在任何情况下，微任务都会早于宏任务执行。

### 5. 监听DOM变化方法的演变

MutationObserver是监听DOM变化的一套方法，监听DOM变化又可以说是前端开发过程中一项非常核心的需求。

在早期的时候，是没有MutationObserver这套方法去监听DOM的变化的。那个时候，观察DOM的是否变化，唯一的方法就是轮询检测，比如使用setTimeout或者setInterval来定时监测DOM是否发生了改变。这种方式粗暴简单，但是也有两个很明显的问题：

- 如果间隔时间设置过长：DOM的变化响应就会不及时；

- 如果间隔时间设置过短：这个时候就会浪费很多无用的工作量去检查DOM，会让页面变得低效；

大概到了2000年的时候引入了Mutation Event，Mutation Event采用了观察者设计模式，当DOM有变动的时候就会立刻触发相应的事件，只是这个时候的这种观察模式属于同步回调。

采用Mutation Event解决了实时性的问题，因为只有在DOM发生了变化的时候才会调用且是立即调用javascript接口。但是也正是这种及时的、高及时性的操作造成了严重的性能问题。因为每次DOM变动，渲染引擎都会立刻去调用Javascript，这样就会产生较大的性能开销。比如在前端开发中，经常会动态的修改或者添加一些DOM节点，那么动态添加或者修改了多少个DOM节点，就会触发多少个的回调，而且每个回调都需要一定的时间。假设每个回调的执行时间是5ms，那么动态添加或者修改50个DOM节点的执行时长就是250ms，那么如果浏览器正在执行的是一个动画效果，那么Mutation Event实时触发回调，就有可能导致动画的卡顿，严重的会导致当前的页面崩溃(早期的浏览器会导致浏览器崩溃，早期的浏览器是单进程的，现在的浏览器基本上是多进程的，只影响到当前页签，或者同一站点的网页)。

正是因为Mutation Event导致的页面性能问题，所以在后来的Web标准中将Mutation Event给删除了。

为了解决Mutation Event由于同步调用js而导致的性能问题，Web标准从DOM4开始推荐使用MutationObserver来代替Mutation Event。MutationObserver可以用来监听DOM的变化，包括属性的变化、DOM节点的增减、内容的变化等。

#### 5.1 相比较Mutation Event，MutationObserver做了哪些改进呢？

1. MutationObserver将响应函数更改为异步调用，可以不用每次在DOM变化时都同步调用，而是等多次DOM变化之后一次触发异步调用，并且还会使用一个数据结构来标记期间发生的所有的DOM的变化。这样，即使是频繁的操作DOM，也不会对性能造成太大的影响。

我们在开发中，通过异步调用和减少触发次数缓解了性能问题，但是怎么保持消息通知的及时性呢？如果使用setTimeout创建宏任务触发的话，就又回到了以前的问题了，实时性会大打折扣。这个时候，就可以使用微任务了。

在每次DOM节点发生变化的时候，渲染引擎将变化记录封装成微任务，并将微任务添加到当前的微任务队列中。这样当执行到检查点的时候，V8引擎就会按照顺序执行微任务了。

由此可见，MutationObserver采用了异步+微任务的策略。

> 通过宏任务与微任务，兼顾的解决了性能与实时性问题。

- 通过异步操作解决了同步操作的性能问题；

- 通过微任务解决了实时性问题；

> WHATWG(Web Hypertext Application Technology Working Group)超文本应用程序技术工作组规范，定义了在主线程的循环系统中，可以有多个消息队列，比如鼠标事件的队列、IO完成消息队列、渲染任务队列，并且可以给这些消息队列排列优先级。

> 但是WHATWG的规范仅仅是一种美好的愿望，在浏览器的实现中，仅仅实现了一个消息队列和一个延迟执行队列。一个是规范，一个是实现。也就是说，理想很丰满，但是有着一个很骨感的现实。