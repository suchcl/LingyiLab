<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [1. 宏任务和微任务](#1-%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1)
  - [2. 宏任务](#2-%E5%AE%8F%E4%BB%BB%E5%8A%A1)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

### 1. 宏任务和微任务

微任务，可以在实时性和效率之间做一个有效的平衡。

微任务，已经被广泛的应用，目前基于微任务的技术有MutationObserver、Promise和很多以Promise为基础开发的很多周边应用。微任务的重要性逐渐提升。

还有一个与微任务对应的宏任务。

#### 2. 宏任务

页面中的大部分事件都是在主线程上执行的(现在的浏览器是多进程的，早期的浏览器是单进程的，Javascript是单线程的)，这些任务主要有：

1. 渲染事件：如DOM解析、样式计算、布局、绘制等

2. 用户交互事件：如鼠标点击、页面滚动、页面缩放等事件

3. javascript脚本执行事件

4. 网络请求完成、文件读写完成事件

为了协调这些任务有条不紊的在主线程上执行，页面进程引入了消息队列和事件循环机制。渲染进程内部会维护多个消息队列，比如延迟执行队列和普通的消息队列。然后主线程采用一个for循环，不断的从这些任务队列中取出任务并执行任务。我们把这些消息队列中的任务称为宏任务。

普通消息队列和延迟执行队列中的任务，都统称为宏任务。

消息队列中的任务是通过事件循环系统来执行的，大概的执行顺序如下：

1. 从多个消息队列中选出最老的任务，这个任务被称为是oldestTask；

2. 然后循环系统记录任务开始执行的时间，并把这个oldestTask设置为当前正在执行的任务；

3. 当任务执行完成之后，删除当前正在执行的任务，并从对应的消息队列中删除掉这个oldestTask；

4. 最后统计执行完成的时长等信息；

> 关于事件循环机制的介绍，可以参考：https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model，这里是最详细、最权威的介绍。

> 中文版的在这里：https://whatwg-cn.github.io/html/#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF

宏任务可以满足大部分的日常需求，但是有些对时间精度要求较高的续期，宏任务就难以满足。

我们知道，页面的渲染事件、各种IO的完成事件、执行js的脚本事件、用户交互事件等都可以随时被添加到消息队列中，但是添加事件到消息队列的动作是由系统操作的，js代码不能准确的掌握任务要添加的在消息丢列中的位置，所以也就很难精准的控制任务的执行时间。

> setTimeout函数出触发的回调函数都是宏任务。

宏任务的时间粒度比较大，执行的时间间隔不能被很好的精准控制，对于一些高实时性的需求不太能满足要求了，比如监听DOM变化的需求。这个时候就可以考虑使用微任务了。

> 微任务的产生，主要解决了宏任务无法兼顾的高实时性的问题，因为宏任务没有办法控制将任务加入到消息队列的时间，没有办法控制宏任务在消息队列中的位置，也就没有办法控制宏任务的执行时间。

### 3. 微任务

我们了解异步回调的概念，异步回调，主要有2种方式：

1. 把异步回调函数封装成一个宏任务，添加到消息队列的尾部，当循环系统执行到该任务的时候执行回调函数。

这种方式比较好理解，如setTimeout和XMLHttpRequest的回调函数就是通过这种方式来实现的。

2. 第二种方式的执行时机是在主函数执行结束之后、当前宏任务结束之前执行回调函数，这通常都是以微任务形式体现的。

**那么到底什么是微任务呢？**

当js在执行一段js的时候，V8会为其创建一个全局的执行上下文，在创建全局执行上下文的同时，V8引擎也会在内部创建一个微任务队列。这个微任务队列就是用来存放微任务的，在当前宏任务执行的过程中，有时候会产生多个微任务，这时候就需要使用这个微任务队列来保存这些微任务了。只是这个微任务队列是给V8引擎内部使用的，我们是没有办法通过js直接访问。

> 事件循环(Event Loop)是各浏览器厂商的，和js引擎(如V8)没有关系，只是浏览器给你提供一个机制，让引擎去执行某些代码。

根据上面的介绍，那就是说，每个宏任务都关联了一个微任务队列。既然这样，那我们就需要关注两个重要的时间点——微任务的产生时机和执行微任务队列的时机。

**微任务的产生**

