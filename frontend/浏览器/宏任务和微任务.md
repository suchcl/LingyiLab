<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [1. 宏任务和微任务](#1-%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1)
  - [2. 宏任务](#2-%E5%AE%8F%E4%BB%BB%E5%8A%A1)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

### 1. 宏任务和微任务

微任务，可以在实时性和效率之间做一个有效的平衡。

微任务，已经被广泛的应用，目前基于微任务的技术有MutationObserver、Promise和很多以Promise为基础开发的很多周边应用。微任务的重要性逐渐提升。

还有一个与微任务对应的宏任务。

#### 2. 宏任务

页面中的大部分事件都是在主线程上执行的(现在的浏览器是多进程的，早期的浏览器是单进程的，Javascript是单线程的)，这些任务主要有：

1. 渲染事件：如DOM解析、样式计算、布局、绘制等

2. 用户交互事件：如鼠标点击、页面滚动、页面缩放等事件

3. javascript脚本执行事件

4. 网络请求完成、文件读写完成事件

为了协调这些任务有条不紊的在主线程上执行，页面进程引入了消息队列和事件循环机制。渲染进程内部会维护多个消息队列，比如延迟执行队列和普通的消息队列。然后主线程采用一个for循环，不断的从这些任务队列中取出任务并执行任务。我们把这些消息队列中的任务称为宏任务。

普通消息队列和延迟执行队列中的任务，都统称为宏任务。

消息队列中的任务是通过事件循环系统来执行的，大概的执行顺序如下：

1. 从多个消息队列中选出最老的任务，这个任务被称为是oldestTask；

2. 然后循环系统记录任务开始执行的时间，并把这个oldestTask设置为当前正在执行的任务；

3. 当任务执行完成之后，删除当前正在执行的任务，并从对应的消息队列中删除掉这个oldestTask；

4. 最后统计执行完成的时长等信息；

> 关于事件循环机制的介绍，可以参考：https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model，这里是最详细、最权威的介绍。

> 中文版的在这里：https://whatwg-cn.github.io/html/#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF

宏任务可以满足大部分的日常需求，但是有些对时间精度要求较高的续期，宏任务就难以满足。