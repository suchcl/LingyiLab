### js的内存管理

js与许多其他现代的编程语言一样，使用自动内存管理，即js会自动完成垃圾回收。这也就意味着，我们在程序运行的时候不需要手动分配内存和释放内存。

自动内存管理(垃圾回收)主要通过标记-清除法完成，主要分为2个阶段：

1. 标记阶段：垃圾收集器从根对象开始，标记所有可到达或可访问的对象；

2. 清除阶段：任何未标记(即无法访问)的对象都被视为“垃圾”，并且其内存将被释放；

但是自动的内存管理无法管理所有场景下的内存问题，所以在一些特殊场景下就会导致出现**内存泄漏**的问题。

### 关于内存泄漏

垃圾回收经常伴随着内存泄漏的概念。这里我们需要理清一个概念：就是内存泄漏和内存溢出是不同的。

> 内存溢出，指的是程序运行过程中需要使用的内存大于系统能够提供的内存。即系统内存不足。

一般所谓的内存泄漏指的是：当一块内存(通常是变量)未被释放(垃圾回收)，同时我们也无法访问到它时。我们也可以简单的理解为：一个变量，我们访问不到它了，但是它占用的内存还没有被回收。那么这个时候，就会出现内存泄漏的问题：

1. 未清理的定时器或者回调

- 场景：使用setInterval或setTimeout，但在组件清理或者不再需要时没有清理

- 结果：定时器还在，引用被保留，导致无法释放内存

```js
function startTimer(){
    setInterval(() => {
        console.log("定时器");
    }, 1000);
}
```

如果调用函数后不清理定时器，那么就会造成内存泄漏。

可按照如下方式进行优化：

```js
const timer = setInterval(() => {
    console.log("定时器");
}, 1000);
clearInterval(timer); // 使用完成后，要及时清理
```

2. DOM引用未释放

3. 闭包中多余的引用

4. 全局变量或未声明变量

5. 事件监听器未清理

6. 忘记清理Set/Map中的键或值

7. 闭环引用