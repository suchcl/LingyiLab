### 防抖函数的核心是什么

**节流**和**防抖**本质都是为了限制函数的执行频次,以优化函数触发频率过高导致的响应速度跟不上触发频率，出现延迟、假死或卡顿的现象。

**防抖**，是指在一定的时间内，在动作被频繁触发的情况下，动作只会被执行一次，也就是说当动作被调用n毫秒之后，动作才会执行。如果在这n毫秒之内又调用此动作，则会重新计算执行时间，所以短时间内的连续动作，只会执行一次。

**节流**：指一定时间内执行的动作只执行一次。这需要提前设定一个事件的执行周期，当调用动作的时间间隔大于该周期，则执行该动作，然后进入下一个周期。就好像眨眼睛一样。

### 防抖函数的使用场景

看如下demo：

```js
let btn = document.getElementById("btn");
btn.addEventListener("click", function(){
    console.log("按钮被点击了");
});
```

如果是页面上单纯点击按钮，则会连续打印文字，但是如果把打印的动作换成是ajax异步请求呢？那么就会频繁的发送请求，服务器接收频率如此之高的请求，承受的压力可想而知会有多大,然后就有可能导致页面的卡顿或者页面假死,都会影响用户的使用体验。

### 防抖函数的核心

在面对上述情形的时候，我们需要想办法改进。比如说在没有下一次触发点击操作的时候，再去执行回调函数，如果是频繁的触发点击操作，那么就永远不执行回调函数，直到在短时间内不再触发新的动作了，再去执行回调函数，去打印信息或者发送网络请求。

这个时候，就需要创建一个防抖函数来处理我们的诉求。这个函数的功能是设置一个定时器，每次点击操作都会触发一个定时输出，如果两次点击时间间隔小于1s，则销毁上一次的定时器，达到最后只有一个定时器输出结果。

**定时器**

在防抖、节流函数中个，最重要的一点就是定时器。比如下面的demo，setTimeout()的功能就是设置了一个定时器，让setTimeout()里面的回调函数延迟1000ms后执行，也就是说触发了点击动作1s后触发回调函数。

```js
setTimeout(function(){
    console.log("Hello World!");
},1000);
```

> setTimeout中的this会指向window。

[关于this的使用，请参考this](./this.md)