## 1.JS技术基础

### ES6中有哪些新特性？

1. 块级作用域
   
   1. 变量声明
      
      1. let
      
      2. const
      
      3. 原来的var
         
         1. 变量的函数作用域
         
         2. 变量提升
         
         3. 全局作用域
            
            1. 在函数外使用var声明变量，会是全局作用域
         
         4. 重复声明
            
            1. var可以重复声明变量，后声明的会覆盖掉前声明的变量
         
         5. 没有块级作用域
         
         6. 容易导致全局污染
   
   2. 块级作用域
      
      1. let、const：声明的变量具有块级作用域
      
      2. var：声明的变量没有块级作用域，但是具有全局作用域
   
   3. 总结：var是javascript中传统的变量声明方式，具有函数级的作用域、变量提升、全局作用域等特性。在一些特殊场景中，这可能是var的一些优势，但是也可以理解为这是它的设计缺陷，如果没有块级作用域，就会导致全局污染，现代的开发中建议使用let、const。

2. 箭头函数
   
   1. 语法简洁
   
   2. 没有自己的this、arguments参数(可以使用剩余参数...rest的方式实现arguments参数的能力)、适合作为回调函数等

3. 模板字符串
   
   1. 语法简洁：避免了使用大量的+和引号来拼接字符串
   
   2. 可读性高：模板字符串结构清晰，易于理解和维护
   
   3. 支持多行：可以直接创建多行字符串，无需手动添加换行符
   
   4. 解构赋值
      
      数组、对象都可以解构赋值
      
      1. 数组结构
      
      2. 对象解构

4. 默认参数
   
   1. es6引入了函数参数默认值的特性。允许在定义函数时为参数指定默认值。当调用函数时，如果没有为这些参数提供值，或者提供的是undefined，那么函数参数将使用默认值
   
   2. 默认值的计算时机：在函数调用时开始计算，而不是在函数定义时
   
   3. 默认参数和剩余参数：默认参数和剩余参数可以一起使用，但是默认参数必须要在剩余参数之前

5. 扩展运算符
   
   1. 扩展运算符就是三个点(...),可以通过将数组和对象展开的方式实现数组和对象的合并
   
   2. 剩余参数

6. 三个点(...)都能完成哪些功能？
   
   1. js中通过展开操作来实现数组和对象的合并
   
   2. 剩余参数：剩余参数用于函数定义，允许开发者将多个参数收集到一个数组中
      
      ```js
      function sum(...numbers) {
          return numbers.reduce((acc, num) => acc + num, 0);
      }
      const result = sum(1, 2, 3, 4, 5);
      console.log(result); // 输出: 15
      ```

7. 类和继承
   
   ES6中引入了类和继承的概念，为js提供了更加简介和清晰的面向对象语法。
   
   可以从定义、构造函数、方法和继承几个方面来全面理解类和继承
   
   **定义** class
   
   **构造函数：**  constructor
   
   **类的方法** 实例方法、静态方法，es22开始可以使用#来定义私有属性和方法，仅限在类内部调用
   
   **继承** 通过extends关键字实现继承，可以继承父类的属性和方法
   
   **super** 有两种用途：1.使用super()调用父类的构造函数； 2. super.methods()调用父类的方法

8. Promise
   
   Promise是js中用于处理异步操作的一个对象，ES6中将其纳入了标准，旨在解决js编程中的回调地域问题。
   
   **基本概念：** Promise代表一个异步操作的最终结果是完成还是失败，并返回其结果。我们可以简单的把它想象成一个容器，里面存放着一个未来才会结束的事件的结果：成功或者失败。
   
   **三种状态：**
   
   pending：进行中。初始状态，既不是成功也不是失败
   
   fulfilled:已成功。事件结束、完成
   
   rejected:已失败。时间结束，为失败了

9. 模块化
   
   js模块化是ES6引入的标准，使得js可以像其他编程语言一样有自己的模块化系统了，可以将代码分割成多个独立的模块，提高代码可可维护性、可复用性和可测试性。
   
   **模块导出**
   
   1. 命名导出  export {},导入时，需要导入指定的模块名称
   
   2. 默认导出 export default，导入时，可以使用任意的名称
   
   **导入**
   
   使用import关键字
   
   **ES6中模块的特点**
   
   1. **静态结构** ES6中的模块是静态的，即在编译时就已经确认了各模块之间的依赖关系和导出内容，这使得静态分析工具如打包工具、代码检查工具等可以更好的优化和处理代码
   
   2. **作用域隔离：** 每个模块都有自己独立的作用域，模块内部的变量、函数等都不会污染全局作用域
   
   3. **按需加载：** 浏览器和node.js等环境都可以按需加载模块，提高资源的利用率和性能

10. Symbol类型

11. 迭代器(Iterators)和可迭代对象(Iterables)

12. 生成器

13. Set和Map数据结构

14. WeakSet 和WeakMap

15. 新增了一些API
    
    1. Object.assign():用于将一个或多个对象的所有可枚举属性复制到目标对象
       
       ```js
       const target = {
           a: 1,
       };
       const source = {
           b: 2,
       };
       const result = Object.assign(target, source);
       console.log(result);
       ```
    
    2. Object.is():用于比较两个值是否相等，与===全等号不同的是，它能处理NaN和-0.
       
       ```js
       const flag = Object.is(NaN, NaN);
       console.log(flag); // true
       ```
    
    3. Array.from():用于将类数组对象或者可迭代对象转换为真正的对象
    
    4. Array.of():
    
    5. find():
    
    6. findIndex():

### 实现数组去重

在js中实现数组去重，可以用以下的一些方法:Set、for循环、filter、reduce等

通过Set对象去重

```js
function unique(arr) {
    return [...new Set(arr)];
}
```

通过for循环去重

```js
function unique3(arr) {
    let res = [];
    for (let i = 0; i < arr.length; i++) {
        if (res.indexOf(arr[i]) === -1) {
            res.push(arr[i]);
        }
    }
    return res;
}
```

通过filter去重

```js
function unique4(arr) {
    return arr.filter((item, index) => {
        return arr.indexOf(item) === index;
    });
}
```

通过reduce去重

```js
function unique2(arr) {
    let res = arr.reduce((pre, cur) => {
        if (!pre.includes(cur)) {
            return pre.concat(cur);
        } else {
            return pre;
        }
    }, []);
    return res;
}
```

### 简述js中的事件循环机制

javascript是单线程的，这意味着它一次只能执行一个任务。事件循环机制是javascript处理异步任务操作的核心机制，它使得javascript可以在单线程的情况下实现异步编程，处理诸如定时器、网络请求等异步任务。

#### 相关概念

##### 1.调用栈

调用栈是一种数据结构，用于跟踪函数的调用顺序。当调用一个函数时，会将该函数的执行上下文压入调用栈，当函数执行完成后，会将其执行上下文从调用栈中弹出。调用栈遵循后进先出的原则。

##### 2. 任务队列

任务队列是一个存储异步任务回调函数的队列，分为宏任务队列和微任务队列。

**宏任务**

常见的宏任务包括：setTimeout、setInterval、I/O操作(HTTP网络请求)、UI渲染等

**微任务**：

常见的微任务有Promise、async/await、MutationObserver等。

##### 3. 事件循环的工作流程

事件循环的主要工作就是不断地从任务队列中取出任务并将其放入调用栈中去执行，其基本流程如下：

1. 执行同步代码：js引擎首先会执行代码中的同步任务，将这些任务依次压入调用栈并执行，直到调用栈为空

2. 检查微任务队列：当调用栈为空时，js引擎就会检查微任务队列，

3. 执行宏任务：

4. 重复2和3：

#### 事件循环的工作流程

1. 执行同步代码

2. 检查微任务队列

3. 执行宏任务

4. 重复2和3

#### 浏览器环境和node.js环境的差异

### 单线程和多线程

单线程和多线程是计算机编程中两种不同的执行模型，它们各有特点，适用于不同的领域和场景。

#### 单线程

**定义**：单线程是指在一个程序中，只有一个执行路径，即同一时间只能执行一个任务。所有的任务都按照顺序依次执行，前一个任务完成后，才能执行后一个任务。

**原理**：以js为例，javascript引擎在单线程环境下运行，它有一个调用栈来管理函数的调用和执行。当代码执行时，函数被依次压入调用栈，然后按照先进后出的原则执行。在执行过程中，如果遇到了异步任务，如定时器setTimeout、setInterval、Promise等，它们不会立即被执行，而是被放入相应的任务队列中。当调用栈中的任务执行完成后，事件循环机制会从任务队列中取出异步任务，将其放入调用栈中去执行。

**优势**：

1. **简单直观**：编程模型简单，开发者不需要处理复杂的线程同步和资源竞争问题，代码逻辑简单、清晰，易于理解和维护

2. **避免资源竞争**：由于同一时间只有一个任务在执行，不会出现多个线程同时访问和修改共享资源的情况，从而避免了资源竞争和数据不同步、不一致的问题。

**缺点**：

1. 阻塞问题：如果某个任务执行时间过长，会阻塞后续任务的执行，导致程序出现卡顿的现象，影响用户体验。例如在浏览器中，如果执行一段复杂的计算或者长时间的网络请求，可能会导致页面失去响应，无法进行其他操作。

2. 无法充分利用多核处理器：在多核处理器环境下，单线程只能利用一个核心，无法充分发挥多核处理器的计算能力，导致资源浪费。

#### 多线程

**定义**：

**工作原理**：



**优势**：

1. 提高响应性

2. 充分利用多核处理器

**缺点**：

1. 编程复杂度高

2. 资源消耗大

### 简述JS中的闭包

闭包是有权访问另外一个函数作用域中变量的函数。其本质上是一个函数

**形成条件**

1. 函数嵌套：一个函数定义在另外一个函数内部

2. 内部函数引用外部函数的变量：内部函数使用了外部函数中定义的变量了

**优势**

1. 数据封装和隐藏

2. 实现函数的私有变量和方法

**缺点**

1. 内存泄漏风险

2. 性能开销

**实际应用场景**

1. 事件处理程序

2. 模块化开发

### 堆栈有什么区别？

在计算机编程领域，尤其是在内存管理方面，堆和栈是两个非常重要的概念，它们在内存分配、数据存储、访问效率、生命周期等方面存在明显的区别。

#### 内存分配

##### 栈内存

1. 由操作系统自动分配和释放。当程序执行时，系统会为每个线程分配一个栈空间，函数调用和局部变量的存储都会在这个栈中去执行

2. 栈内存分配和释放都非常快，因为它遵循后进先出的原则，类似于在箱子里放东西和取东西，只需要在栈顶进行操作

##### 堆内存

1. 由程序员进行手动的分配和释放：现在大部分的高级编程语言可以实现自动的垃圾回收机制，在一些场景下可以自动的实现内存的自动释放。当程序需要动态分配内存空间时，会向操作系统请求堆内存空间

2. 堆内存的分配和释放相对较慢。因为需要操作系统进行复杂的内存管理操作，如查找可用的内存块、标记和清除不再使用的内存等。

#### 数据存储

##### 栈内存

1. 主要用于存储局部变量、函数调用的上下文信息如函数参数、返回地址等，这些数据的大小和生命周期在编译时通常是已知的

2. 在一个函数中定义的基本数据类型的变量如整数、浮点数、布尔值等，都会存储在栈内存中

```js
function example() {
    let num = 10; // num 存储在栈内存中
    let bool = true; // bool 存储在栈内存中
}
```

##### 堆内存

1. 堆内存用于存储动态分配的数据，如数组、对象等。这些数据的大小和生命周期在运行时才能确定。

2. js中创建对象和数组，会存放在堆内存中。
   
   ```js
   function createObject() {
       let obj = { name: 'John', age: 30 }; // obj 存储在堆内存中
       let arr = [1, 2, 3]; // arr 存储在堆内存中
   }
   ```

#### 访问效率

##### 栈内存

1. 访问速度快。因为栈的内存地址是连续的，操作系统可以直接通过指针快速定位到栈顶元素

2. 堆栈内存的操作通常只需要简单的移动指针，因此效率较高

##### 堆内存

1. 访问速度相对较慢，因为堆内存地址的分配不是连续的，需要通过指针来间接访问

2. 在访问堆内存中的数据时，需要先找到对象的引用地址，然后再通过该地址访问对象的属性和方法

#### 生命周期

#### 数据共享和并发问题

### for……of和for……in有什么区别？

### JS实现深拷贝

### JS实现截流与防抖

## 2.TS基础

## 3.Vue

### vue2和vue3有哪些区别？

### vue3中setup语法糖

## 4. React

### React中都有哪些hooks？

### 项目中用到过哪些hooks？

### setState和useState有什么联系和区别？

### 这些hooks的都是为了解决哪些问题，有什么样的应用场景？

### useMemo和useCallback有什么区别？

### React中组件之间的通信方式有哪些？

### React中的状态管理

### React中的代码分割、懒加载

## 5. Taro

### 小程序中，除了你写的那些优化措施之外，还有哪些其他的优化方式？效果如何？

### Taro的渲染机制是什么？

### Taro和uni-app的区别是什么？

## 6. 综合应用

### 跨域问题

1. 什么是跨域

2. 都是怎么解决的？

3. 开发环境怎么解决跨域问题？
   
   1. vue2
   
   2. vue3
   
   3. react中
   
   4. webpack
   
   5. vite

4. 实际场景问题、注意点

### 你项目中遇到过什么问题，怎么解决的？

### 移动端项目中遇到过哪些兼容性问题？

### 前端项目中都有哪些常用性能优化方法或者手段？